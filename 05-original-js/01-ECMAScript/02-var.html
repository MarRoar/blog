<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>变量的定义</title>
	<style>
		.question {
			background-color: yellow;
			color: red;
		}
	</style>
</head>
<body>
	<div>
		<h2>变量的定义</h2>
		<p>
			ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。<br>其实也就是说每一个变量仅仅是一个用于保存值的占位符。定义变量用 var 关键字，这个在 ES5 里面是这样定义的，后面也会说到 ES6 里面新增加的定义变量的方法和区别。<br>
			定义一个变量 <code> var message </code> 定义了一个 message 的变量，这个变量可以用来保存任何值(如果初始化没有赋值，则变量会保存一个默认的值 undefined) <br>
			<code>var message = 'hi'</code><br>
			message 在一开始保存了一个字符串值 'hi',。像这样初始化变量并不会把它标记为字符串类型；初始化的过程就是给变量赋一个值那么简单。因此，可以在修改变量值的同时修改值的类型。
			<code>var message = 'hi'</code><br>
			<code>message = 100</code><br>
			var 在定义的变量成为定义该变量的作用域中的局部变量。也就是说如果在函数中用 var 定义一个变量，那么在函数退出后就会被销毁。<br>
			如果在函数里面如果省略 var 则这个变量会被定义成全局变量。<br>
		</p>
		<span>有var 和 没有 var 定义变量的区别</span>
		<ol>
			<li>在函数里面var 会定义成局部变量，无var 会定义成全局变量</li>
			<li>是否可以被 delete 删除</li>
			<li>是否会被变量提示</li>
		</ol>
	</div>
	<div>
		<p>ES6 里面定义的变量， let const </p>
		<p>
			let：let的用法和 var 有点类似，但是let声明的变量只有在代码块(代码块就是{}内)内有效,var 定义的变量在代码外也可以成功访问到，比如 for 循环里面. <br>
			let定义的变量没有变量提升。 <br>
			let 不允许在相同作用域内，重复声明同一个变量。

		</p>
		<p>
			const声明一个只读的常量。<br>
			const实际上保证的并不是变量的值不变，而是变量指向的那个内存地址不变，<br>

			对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针

		</p>
		<p>
			ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。
		</p>
		
	</div>
	<article class="question">
		问题：
		没有类型的变量在内存中是怎么存储的？其他有类型的变量在内存中是怎么存储的呢？
	</article>

	<div>
		<p>补充</p>
		<strong>
			<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank">阮一峰ES6</a> <br>
			ES5 只有全局作用域和函数作用域。
			ES6 中let的引入新增了块级作用域，
		</strong>
		<strong>
			<p>ES6 里面有个 <a href="http://es6.ruanyifeng.com/#docs/destructuring">结构赋值</a>这个东西有点类似于Python里面的元组赋值，可以对比着Python和JavaScript来看这个功能。</p>
		</strong>
	</div>
	<script>
		console.log('a', a)

		var a = 100;
		b = 100;
		delete window.a;
		delete window.b;
		console.log(window);

		let c = 11; // 声明的全局变量就不属于 window 的属性或者方法了
		console.log(window.c);


		(function () {
			console.log("立即执行函数表达式 IIFE")
		})();

		{
			console.log('块级作用域，可以取代IIFE')
		}

	</script>
</body>
</html>