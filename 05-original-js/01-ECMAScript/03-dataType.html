<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>数据类型</title>
	<style>
		.question {
			background-color: yellow;
			color: red;
		}
	</style>
</head>
<body>
	<article>
		<h2>ES5 数据类型</h2>
		<ul>
			<li>ES5 里面有什么数据类型？</li>
			<li>怎么判断数据类型？</li>
			<li>ES6 有没有新补充数据类型？如果有是什么？</li>
			<li>数据类型个在内存中的存储？</li>
		</ul>
	</article>
	<article>
		<p>在ES5 中规定的有5种基本数据类型(), Undefined,Null,Boolean,Number,String和1种复杂类型Object。ES5 不支持任何创建自定义类型的机制，而所有值最终都将是上述6 种数据类型之一。常用于检测数据类型的是 typeof 操作符因此例子中的圆括号尽管可以使用，但不是必需的。</p>
		<p>在ES6 中基本类型的数据又增加了 Symbol</p>
		<p>typof null 的时候返回的是 object，因为特殊值 null 被认为是一个空的对象的引用</p>
		<p>在内存里面 比本类型的数据是放在栈内存里面的，引用类型的数据是放在堆内存里面</p>
		<p>
			对于引用类型的数据如果想要判断是由什么函数实例化的 可以用 instanceof 来判断
		</p>
		<p>
			为什么 null 和 undefined 比较(==)的时候是相等的，那是因为undefined的值是派生自 null的值,在使用 == 时候会转换操作的数据的，如果用 === 就是 false 了。<br>
		</p>
	</article>
	<article>
		<ul>
			<li>
				undefined: <br>
				使用 var 初始化变量未赋值的时候，这个变量默认的值是 undefined。<br>
				如果一个变量没有被声明 typeof 变量，的结果也是 undefined。
			</li>
			<li>
				null: <br>
				null 从逻辑角度来看 null 值表示一个空对象的指针。<br>
				为什么 null 和 undefined 比较(==)的时候是相等的，那是因为undefined的值是派生自 null的值,在使用 == 时候会转换操作的数据的，如果用 === 就是 false 了。<br>
				null 和 undefined 在使用上是有区别的，如果初始化的变量是 引用类型的话，最好使用 null,如果是基本类型的话就使用 undefined，当然你也可以不用传默认值。
			</li>
			<li>
				boolean: <br>
				Boolean 该类型只有两个字面值 true 和 false <br>
				ECMAScript 中的所有数据类型都可以转换成 Boolean值。 <br>
				0, '', NaN, null, undefined转换成 false， 其他情况转换成 true <br>
			</li>
			<li>
				Number: <br>
				数据类型的 整数和浮点数, 数值范围，NaN, 数值转换， <br>
				<p>
					浮点数为什么会失去精度，主要是因为浮点数值需要的内存空间是整数的两倍，因此 ECMAScript 会不失去时机地将浮点数值转换为整数值。
				</p>
			</li>
			<li>
				String: <br>
				<p>
					ECMAScript 中字符串是不可变的，如果要改变的，就要先销毁之前的数据。
					<code>
						<br>
						var lang = 'java'; <br>
						lang = lang + 'Script';
					</code>
					<p>
						数值，布尔，对象和字符串值都有 toString() 方法, null 和 undefined 没有这个方法。
						<br>
						还有一个 String() 方法也可以将其他类型转换成 String 类型 <br>
						<code>
							String(10); // '10' <br>
							String(null); // 'null' <br>
							String(undefined); // 'undefined' <br>
						</code>
					</p>
				</p>
			</li>
			<li>
				Object: 类型 <br>
				在 ECMAScript 中 object类型是所有它的实例的基础，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。
				<p>Object 的每个实例都具有下列属性和方法。</p>	
				<p>constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是Object()。</p>
				<p>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）。</p>
				<p>isPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第5 章将讨论原型）。</p>
				<p>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in 语句（本章后面将会讨论）来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。</p>
				<p>toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。</p>
				<p>toString()：返回对象的字符串表示。</p>
				<p>valueOf()：返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。</p>
			</li>
		</ul>
	</article>
	<article>
		在 ES6 中新增加了一种类型的数据 Symbol,
	</article>

	<article class="question">
		问题：
		其他语言是否有从其他类型转换成 Boolean 类型的方法?
	</article>

	<script>
		console.log(typeof a); // undefined
		console.log(typeof (1)); // number
		console.log(typeof '1'); // string
		console.log(typeof false); // boolean

		var ob = {}
		function fn() {}
		console.log(typeof null); // object
		console.log(typeof ob); // object
		console.log(typeof fn); // function

		console.log(({}) instanceof Object)              // true
		console.log(([]) instanceof Array)               // true
		console.log((/aa/g) instanceof RegExp)           // true
		console.log((function(){}) instanceof Function)  // true

		console.log(null == undefined)
		console.log(null === undefined)


		// Number.prototype.hello = function () {
		// 	console.log('hello');
		// }
		// let a= 3;
		// let b = new Number(3);
		// console.log(a);
		// console.log(b);

		// console.log(typeof a)
		// console.log(typeof b)

		// console.log( b instanceof Number)

		// a.hello()
		
		// var symbolObject = (function(){ return this; }).call(Symbol("a"));

		// console.log(typeof symbolObject); //object
		// console.log(symbolObject instanceof Symbol); //true
		// console.log(symbolObject.constructor == Symbol); //true


		// let symbolObject = (function () {return this;}).call(Symbol('a'));

		// console.log(typeof symbolObject);
		// console.log(symbolObject instanceof Symbol);

		// var symbolObject = Object(Symbol('a'));
		// console.log(symbolObject instanceof Symbol);
		// console.log(Object.prototype.toString.call(symbolObject));


		var o = {
			valueOf: function () {
				console.log('valueOf');
				return {}
			},
			toString: function () {
				console.log('toString');
				return {}
			}
		}
		o - 2;
		o + '';


		// let o = {
		// 	valueOf: function () {
		// 		console.log('valueOf');
		// 		return {}
		// 	},
		// 	toString: function () {
		// 		console.log('toString');
		// 		return {}
		// 	}
		// }
		// o[Symbol.toPrimitive] = () => {
		// 	console.log('toPrimitive');
		// 	return 'hello'
		// }

		// console.log(o + '');
	</script>
</body>
</html>